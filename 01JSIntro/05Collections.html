<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="favicon.svg" />
  <link rel="stylesheet" href="style.css">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Vite App</title>
</head>
<body>
<!--script type="module" src="/main.js"></script-->
<main>
<h1>Objects and Arrays</h1>
<h2>Objects</h2>
An object can be created with figure brackets {...} with an optional list of properties. A property
is a “key: value” pair, where key is a string (also called a “property name”), and value can
be anything.

One of the fundamental differences of objects vs primitives is that they are stored and copied
“by reference”.

<p><b>A variable stores not the object itself, but its “address in memory”, in other words “a
  reference” to it.</b></p>

<p><b>primitives are immutable while objects are mutable</b></p>

<p><b>When an object variable is copied - the reference is copied, the object is 
  not duplicated.</b></p>

<pre>
let user = new Object(); // "object constructor" syntax
let user = {}; // "object literal" syntax
let user = { // an object
  name: "John", // by key "name" store value "John"
  age: 30 // by key "age" store value 30
};

console.log( user.name );
console.log( user.age );

user.isAdmin = true;

delete user.age;
</pre>
We can also use multiword property names, but then they must be quoted:
<pre>
  let user = {
    name: "John",
    age: 30,
    "likes birds": true 
  };

  user.likes reading = true; //syntax error
  user["likes reading"] = true;

  console.log(user["likes birds"]); // get
  delete user["likes birds"]; // delete

  console.log(user)
</pre>

Destructring Object
<pre>
  let {name} = {name: "Faraji", age: 23};
  console.log(name);
  // → Faraji
</pre>

Reading a property that doesn’t exist will give you the value undefined.
<pre>
let day1 = {
  squirrel: false,
  events: ["work", "touched tree", "pizza", "running"]
};
console.log(day1.squirrel);
console.log(day1.wolf);
</pre>

There also exists a special operator "in" to check for the existence of a property.
<pre>
  let user = { name: "John", age: 30 };
  console.log( "age" in user );
  console.log( "blabla" in user );
</pre>

To find out what properties an object has, you can use the <b>Object.keys</b>
function. You give it an object, and it returns an array of strings—the object’s
property names.
<pre>
  console.log(Object.keys({x: 0, y: 0, z: 2}));
</pre>

There’s an <b>Object.assign</b> function that copies all properties from one object
into another.
<pre>
let objectA = {a: 1, b: 2};
Object.assign(objectA, {b: 3, c: 4});
console.log(objectA);
</pre>

<h4>The “for…in” loop</h4>
To walk over all keys of an object, there exists a special form of the 
loop: for..in . This is a completely different thing from the for(;;) 
construct that we studied before.
<pre>
  //syntax
  for (key in object) {
    // executes the body for each key among object properties
  }

  let user = {
    name: "John",
    age: 30,
    isAdmin: true
  };

  for (let key in user) {
    console.log( key + " => " + user[key]);
  }
</pre>



<h2>Arrays</h2>
Arrays allow you to store ordered collections of values.

<pre>
  let arr = new Array("Apple", "Pear", "etc");
  let fruits = ["Apple", "Orange", "Plum"];
  console.log( fruits[1] );
  fruits[2] = 'Pear';
  fruits[3] = 'Lemon';
  console.log(fruits.length);
  console.log(fruits);
</pre>

An array can store elements of any type.
<pre>
  let arr = [ 'Apple',
              { name: 'John' },
              true,
              function() { console.log('hello'); }
            ];
  alert( arr[1].name ); 
  arr[3]();
</pre>

Use the static <b>Array.isArray()</b> method for checking If an Object Is an Array
<pre>
  const browserNames = ['Firefox', 'Edge', 'Chrome', 'IE', 'Safari'];
  if (Array.isArray(browserNames)) {
    // We end up here, because browserNames is a valid array.
  }
</pre>

<h5>Array Methods</h5>
<b>pop</b> Extracts the last element of the array and returns it <br>
<b>push</b> Append the element to the end of the array:
<pre>
let fruits = ["Apple", "Orange", "Pear"];
console.log( fruits.pop() );
console.log( fruits );

let fruits = ["Apple", "Orange"];
fruits.push("Pear");
console.log( fruits );
</pre>

<b>shift:</b> Extracts the first element of the array and returns it <br>
<b>unshift:</b> Add the element to the beginning of the array:
<pre>
let fruits = ["Apple", "Orange", "Pear"];
console.log( fruits.shift() );
console.log( fruits );

let fruits = ["Orange", "Pear"];
fruits.unshift('Apple');
console.log( fruits ); 
</pre>

Methods push and unshift can add multiple elements at once:
<pre>
let fruits = ["Apple"];
fruits.push("Orange", "Peach");
fruits.unshift("Pineapple", "Lemon");
console.log( fruits );
</pre>

<h5>Looping Arrays</h5>
One of the oldest ways to cycle array items is the for loop over indexes:
<pre>
  let arr = ["Apple", "Orange", "Pear"];
  
  for (let i = 0; i &lt arr.length; i++) {
  console.log( arr[i] );
  }
</pre>
But for arrays there is another form of loop, <b>for..of</b> :
<pre>
  let fruits = ["Apple", "Orange", "Plum"];

  // iterates over array elements
  for (let fruit of fruits) {
    console.log( fruit );
  }
</pre>
Technically, because arrays are objects, it is also possible to use <b>for..in</b> 
But that’s actually a bad idea. There are potential problems with it::
<pre>
  let arr = ["Apple", "Orange", "Pear"];
  
  for (let key in arr) {
    console.log( arr[key] ); // Apple, Orange, Pear
  }
</pre>

<h4>Multidimensional arrays</h4>
Arrays can have items that are also arrays. We can use it for multidimensional arrays, for
example to store matrices:
<pre>
  let matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
  ];

  console.log( matrix[1][1] );
</pre>

<h4>toString</h4>
Arrays have their own implementation of toString method that returns a comma-separated
list of elements

<pre>
  let arr = [1, 2, 3];
  alert( arr ); 
  alert( String(arr) === '1,2,3' ); 


  alert( [] + 1 ); // "1"
  alert( [1] + 1 ); // "11"
  alert( [1,2] + 1 ); // "1,21"
</pre>

<h4>splice</h4>
The arrays are objects, so we can try to use delete :
<pre>
  let arr = ["I", "go", "home"];
  delete arr[1];
  console.log( arr[1] );
  console.log( arr.length ); 
</pre>

The <b>arr.splice(str)</b> method is a swiss army knife for arrays. It can do everything: insert,
remove and replace elements.
The syntax is:
<pre>
arr.splice(index[, deleteCount, elem1, ..., elemN]) ;
</pre>
It starts from the position index : removes deleteCount elements and then inserts
elem1, ..., elemN at their place. Returns the array of removed elements.

<pre>
  let arr = ["I", "study", "JavaScript"];
  arr.splice(1, 1); // from index 1 remove 1 element
  console.log( arr ); // ["I", "JavaScript"]
</pre>

<pre>
  let arr = ["I", "study", "JavaScript", "right", "now"];
  // remove 3 first elements and replace them with another
  arr.splice(0, 3, "Let's", "dance");
  alert( arr ) // now ["Let's", "dance", "right", "now"]
</pre>

In the next example we remove 3 elements and replace them with the other two:
<pre>
let arr = ["I", "study", "JavaScript", "right", "now"];
// remove 3 first elements and replace them with another
arr.splice(0, 3, "Let's", "dance");
console.log( arr ) // now ["Let's", "dance", "right", "now"]
</pre>

Here we can see that splice returns the array of removed elements:
<pre>
  let arr = ["I", "study", "JavaScript", "right", "now"];
  // remove 2 first elements
  let removed = arr.splice(0, 2);
  console.log( removed ); // "I", "study" -- array of removed elements
</pre>

The splice method is also able to insert the elements without any removals. For that we
need to set <b>deleteCount</b> to 0 :
<pre>
let arr = ["I", "study", "JavaScript"];
// from index 2
// delete 0
// then insert "complex" and "language"
arr.splice(2, 0, "complex", "language");
alert( arr ); // "I", "study", "complex", "language", "JavaScript"
</pre>
Here and in other array methods, negative indexes are allowed. They specify the position
from the end of the array, like here:
<pre>
  let arr = [1, 2, 5];
  // from index -1 (one step from the end)
  // delete 0 elements,
  // then insert 3 and 4
  arr.splice(-1, 0, 3, 4);
  alert( arr ); // 1,2,3,4,5
</pre>

<h4>slice</h4>
The method arr.slice  is much simpler than similar-looking arr.splice .
The syntax is:
<pre>
arr.slice(start, end)
</pre>

<pre>
let str = "test";
let arr = ["t", "e", "s", "t"];
alert( str.slice(1, 3) ); // es
alert( arr.slice(1, 3) ); // e,s
alert( str.slice(-2) ); // st
alert( arr.slice(-2) ); // s,t
</pre>




<h3>JSON</h3>
<p>Because properties only grasp their value, rather than contain it, objects and
  arrays are stored in the computer’s memory as sequences of bits holding the
  addresses—the place in memory—of their contents.</p>

<p>If you want to save data in a file for later or send it to another computer over
  the network, you have to somehow convert these tangles of memory addresses
  to a description that can be stored or sent. </p>

<p>A popular serialization format is called JSON (pronounced
  “Jason”), which stands for JavaScript Object Notation. It is widely used as a
  data storage and communication format on the Web, even in languages other
  than JavaScript.</p>

<p>JSON looks similar to JavaScript’s way of writing arrays and objects, with a
  few restrictions. 
  <li>All property names have to be surrounded by double quotes</li>
  <li>Only simple data expressions are allowed—no function calls, bindings, or
    anything that involves actual computation.</li>
  <li>Comments are not allowed in JSON.</li>
</p>
<pre>
  let string = JSON.stringify({
    squirrel: false,
    events: ["weekend"]
  });

  console.log(string);

  console.log(JSON.parse(string).events);
  
</pre>
</main>


<script type="text/javascript">

</script>


<style>
body {
  background-color: lightgray;
};
main {
  background-color: white;
  margin-left: 2pt;
  margin-right: 2pt;
  margin-bottom: 2cm;
  padding: 20pt;
};

pre {
  background-color: lightgoldenrodyellow;
  padding: 10pt; 
};
</style>

</body>
</html>
